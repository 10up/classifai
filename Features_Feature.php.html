<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: Features/Feature.php - 10up ClassifAI Hook Docs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">

	<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans:300,400|Playfair+Display:900&display=swap" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="styles-10up.css">
</head>

<body>

<div id="main">

	
    <h1 class="page-title">Source: Features/Feature.php</h1>
	

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&lt;?php

namespace Classifai\Features;

use WP_REST_Request;
use WP_Error;
use function Classifai\find_provider_class;

abstract class Feature {
	/**
	 * ID of the current feature.
	 *
	 * To be set in the subclass.
	 *
	 * @var string
	 */
	const ID = '';

	/**
	 * Feature label.
	 *
	 * @var string
	 */
	public $label = '';

	/**
	 * User role array.
	 *
	 * @var array
	 */
	public $roles = [];

	/**
	 * Array of provider classes.
	 *
	 * This contains all the providers that are registered to the service.
	 *
	 * @var \Classifai\Providers\Provider[]
	 */
	public $provider_instances = [];

	/**
	 * Array of providers supported by the feature.
	 *
	 * @var \Classifai\Providers\Provider[]
	 */
	public $supported_providers = [];

	/**
	 * Set up necessary hooks.
	 */
	public function setup() {
		add_action( 'admin_init', [ $this, 'setup_roles' ] );
		add_action( 'admin_init', [ $this, 'register_setting' ] );
		add_action( 'admin_init', [ $this, 'setup_fields_sections' ] );

		if ( $this->is_feature_enabled() ) {
			$this->feature_setup();
		}
	}

	/**
	 * Setup any hooks the feature needs.
	 *
	 * Only fires if the feature is enabled.
	 */
	public function feature_setup() {
	}

	/**
	 * Assigns user roles to the $roles array.
	 */
	public function setup_roles() {
		$default_settings = $this->get_default_settings();
		$this->roles      = get_editable_roles() ?? [];
		$this->roles      = array_combine( array_keys( $this->roles ), array_column( $this->roles, 'name' ) );

		// Remove subscriber from the list of roles.
		unset( $this->roles['subscriber'] );

		/**
		 * Filter the allowed WordPress roles for a feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_roles
		 *
		 * @param {array} $roles            Array of arrays containing role information.
		 * @param {array} $default_settings Default setting values.
		 *
		 * @return {array} Roles array.
		 */
		$this->roles = apply_filters( 'classifai_' . static::ID . '_roles', $this->roles, $default_settings );
	}

	/**
	 * Returns the label of the feature.
	 *
	 * @return string
	 */
	public function get_label(): string {
		/**
		 * Filter the feature label.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_label
		 *
		 * @param {string} $label Feature label.
		 *
		 * @return {string} Filtered label.
		 */
		return apply_filters(
			'classifai_' . static::ID . '_label',
			$this->label
		);
	}

	/**
	 * Set up the fields for each section.
	 *
	 * @internal
	 */
	public function setup_fields_sections() {
		$settings = $this->get_settings();

		add_settings_section(
			$this->get_option_name() . '_section',
			esc_html__( 'Feature settings', 'classifai' ),
			'__return_empty_string',
			$this->get_option_name()
		);

		// Add the enable field.
		add_settings_field(
			'status',
			esc_html__( 'Enable feature', 'classifai' ),
			[ $this, 'render_input' ],
			$this->get_option_name(),
			$this->get_option_name() . '_section',
			[
				'label_for'     => 'status',
				'input_type'    => 'checkbox',
				'default_value' => $settings['status'],
				'description'   => $this->get_enable_description(),
			]
		);

		// Add all the needed provider fields.
		$this->add_provider_fields();

		// Add any needed custom fields.
		$this->add_custom_settings_fields();

		// Add user/role-based access fields.
		$this->add_access_control_fields();
	}

	/**
	 * Get the description for the enable field.
	 *
	 * @return string
	 */
	public function get_enable_description(): string {
		return '';
	}

	/**
	 * Add any needed custom fields.
	 */
	public function add_custom_settings_fields() {
	}

	/**
	 * Returns the default settings for the feature.
	 *
	 * The root-level keys are the setting keys that are independent of the provider.
	 * Provider specific settings should be nested under the provider key.
	 *
	 * @internal
	 * @return array
	 */
	protected function get_default_settings(): array {
		$shared_defaults   = [
			'status'             => '0',
			'roles'              => array_combine( array_keys( $this->roles ), array_keys( $this->roles ) ),
			'users'              => [],
			'user_based_opt_out' => 'no',
		];
		$provider_settings = $this->get_provider_default_settings();
		$feature_settings  = $this->get_feature_default_settings();

		/**
		 * Filter the default settings for a feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_get_default_settings
		 *
		 * @param {array} $defaults Default feature settings.
		 * @param {object} $this Feature instance.
		 *
		 * @return {array} Filtered default feature settings.
		 */
		return apply_filters(
			'classifai_' . static::ID . '_get_default_settings',
			array_merge(
				$shared_defaults,
				$feature_settings,
				$provider_settings
			),
			$this
		);
	}

	/**
	 * Sanitizes the settings before saving.
	 *
	 * @internal
	 * @param array $settings The settings to be sanitized on save.
	 * @return array
	 */
	public function sanitize_settings( array $settings ): array {
		$new_settings     = $settings;
		$current_settings = $this->get_settings();

		// Sanitize the shared settings.
		$new_settings['status']   = $settings['status'] ?? $current_settings['status'];
		$new_settings['provider'] = isset( $settings['provider'] ) ? sanitize_text_field( $settings['provider'] ) : $current_settings['provider'];

		// Allowed roles.
		if ( isset( $settings['roles'] ) &amp;&amp; is_array( $settings['roles'] ) ) {
			$new_settings['roles'] = array_map( 'sanitize_text_field', $settings['roles'] );
		} else {
			$new_settings['roles'] = $current_settings['roles'];
		}

		// Allowed users.
		if ( isset( $settings['users'] ) &amp;&amp; ! empty( $settings['users'] ) ) {
			if ( is_array( $settings['users'] ) ) {
				$new_settings['users'] = array_map( 'absint', $settings['users'] );
			} else {
				$new_settings['users'] = array_map( 'absint', explode( ',', $settings['users'] ) );
			}
		} else {
			$new_settings['users'] = array();
		}

		// User-based opt-out.
		if ( empty( $settings['user_based_opt_out'] ) || 1 !== (int) $settings['user_based_opt_out'] ) {
			$new_settings['user_based_opt_out'] = 'no';
		} else {
			$new_settings['user_based_opt_out'] = '1';
		}

		// Sanitize the feature specific settings.
		$new_settings = $this->sanitize_default_feature_settings( $new_settings );

		// Sanitize the provider specific settings.
		$provider_instance = $this->get_feature_provider_instance( $new_settings['provider'] );
		$new_settings      = $provider_instance->sanitize_settings( $new_settings );

		/**
		 * Filter to change settings before they're saved.
		 *
		 * @since 3.0.0
		 * @hook classifai_{$feature}_sanitize_settings
		 *
		 * @param {array} $new_settings     Settings being saved.
		 * @param {array} $current_settings Existing settings.
		 *
		 * @return {array} Filtered settings.
		 */
		return apply_filters(
			'classifai_' . static::ID . '_sanitize_settings',
			$new_settings,
			$current_settings
		);
	}

	/**
	 * Sanitize the default feature settings.
	 *
	 * @param array $settings Settings to sanitize.
	 * @return array
	 */
	public function sanitize_default_feature_settings( array $settings ): array {
		return $settings;
	}

	/**
	 * Registers the settings for the feature.
	 */
	public function register_setting() {
		register_setting(
			$this->get_option_name(),
			$this->get_option_name(),
			[
				'sanitize_callback' => [ $this, 'sanitize_settings' ],
			]
		);
	}

	/**
	 * Returns the option name for the feature.
	 *
	 * @return string
	 */
	public function get_option_name(): string {
		return 'classifai_' . static::ID;
	}

	/**
	 * Returns the settings for the feature.
	 *
	 * @param string $index The index of the setting to return.
	 * @return array|mixed
	 */
	public function get_settings( $index = false ) {
		$defaults = $this->get_default_settings();
		$settings = get_option( $this->get_option_name(), [] );
		$settings = $this->merge_settings( (array) $settings, (array) $defaults );

		if ( $index &amp;&amp; isset( $settings[ $index ] ) ) {
			return $settings[ $index ];
		}

		return $settings;
	}

	/**
	 * Returns the default settings for the provider selected for the feature.
	 *
	 * @return array
	 */
	public function get_provider_default_settings(): array {
		$provider_settings = [];

		foreach ( array_keys( $this->get_providers() ) as $provider_id ) {
			$provider = $this->get_feature_provider_instance( $provider_id );

			if ( $provider &amp;&amp; method_exists( $provider, 'get_default_provider_settings' ) ) {
				$provider_settings[ $provider_id ] = $provider->get_default_provider_settings();
			}
		}

		return $provider_settings;
	}

	/**
	 * Returns the default settings for the feature.
	 *
	 * @return array
	 */
	abstract public function get_feature_default_settings(): array;

	/**
	 * Add the provider fields.
	 *
	 * Will add a field to choose the provider and any
	 * fields the selected provider has registered.
	 */
	public function add_provider_fields() {
		$settings = $this->get_settings();

		add_settings_field(
			'provider',
			esc_html__( 'Select a provider', 'classifai' ),
			[ $this, 'render_select' ],
			$this->get_option_name(),
			$this->get_option_name() . '_section',
			[
				'label_for'     => 'provider',
				'options'       => $this->get_providers(),
				'default_value' => $settings['provider'],
			]
		);

		foreach ( array_keys( $this->get_providers() ) as $provider_id ) {
			$provider = $this->get_feature_provider_instance( $provider_id );

			if ( $provider &amp;&amp; method_exists( $provider, 'render_provider_fields' ) ) {
				$provider->render_provider_fields();
			}
		}
	}

	/**
	 * Merges the data settings with the default settings recursively.
	 *
	 * @internal
	 *
	 * @param array $settings  Settings data from the database.
	 * @param array $defaults  Default feature and providers settings data.
	 * @return array
	 */
	protected function merge_settings( array $settings = [], array $defaults = [] ): array {
		foreach ( $defaults as $key => $value ) {
			if ( ! array_key_exists( $key, $settings ) ) {
				$settings[ $key ] = $defaults[ $key ];
			} elseif ( is_array( $value ) ) {
				if ( is_array( $settings[ $key ] ) ) {
					$settings[ $key ] = $this->merge_settings( $settings[ $key ], $defaults[ $key ] );
				} else {
					$settings[ $key ] = $defaults[ $key ];
				}
			}
		}

		return $settings;
	}

	/**
	 * Returns the providers supported by the feature.
	 *
	 * @internal
	 * @return array
	 */
	protected function get_providers(): array {
		/**
		 * Filter the feature providers.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_providers
		 *
		 * @param {array} $providers Feature providers.
		 *
		 * @return {array} Filtered providers.
		 */
		return apply_filters(
			'classifai_' . static::ID . '_providers',
			$this->supported_providers
		);
	}

	/**
	 * Resets settings for the provider.
	 */
	public function reset_settings() {
		update_option( $this->get_option_name(), $this->get_default_settings() );
	}

	/**
	 * Add settings fields for Role/User based access.
	 */
	protected function add_access_control_fields() {
		$settings = $this->get_settings();

		add_settings_field(
			'roles',
			esc_html__( 'Allowed roles', 'classifai' ),
			[ $this, 'render_checkbox_group' ],
			$this->get_option_name(),
			$this->get_option_name() . '_section',
			[
				'label_for'      => 'roles',
				'options'        => $this->roles,
				'default_values' => $settings['roles'],
				'description'    => __( 'Choose which roles are allowed to access this feature.', 'classifai' ),
				'class'          => 'allowed_roles_row',
			]
		);

		add_settings_field(
			'users',
			esc_html__( 'Allowed users', 'classifai' ),
			[ $this, 'render_allowed_users' ],
			$this->get_option_name(),
			$this->get_option_name() . '_section',
			[
				'label_for'     => 'users',
				'default_value' => $settings['users'],
				'description'   => __( 'Users who have access to this feature.', 'classifai' ),
				'class'         => 'allowed_users_row',
			]
		);

		add_settings_field(
			'user_based_opt_out',
			esc_html__( 'Enable user-based opt-out', 'classifai' ),
			[ $this, 'render_input' ],
			$this->get_option_name(),
			$this->get_option_name() . '_section',
			[
				'label_for'     => 'user_based_opt_out',
				'input_type'    => 'checkbox',
				'default_value' => $settings['user_based_opt_out'],
				'description'   => __( 'Enables ability for users to opt-out from their user profile page.', 'classifai' ),
				'class'         => 'classifai-user-based-opt-out',
			]
		);
	}

	/**
	 * Generic text input field callback
	 *
	 * @param array $args The args passed to add_settings_field.
	 */
	public function render_input( array $args ) {
		$option_index  = isset( $args['option_index'] ) ? $args['option_index'] : false;
		$setting_index = $this->get_settings( $option_index );
		$type          = $args['input_type'] ?? 'text';
		$value         = ( isset( $setting_index[ $args['label_for'] ] ) ) ? $setting_index[ $args['label_for'] ] : '';

		// Check for a default value
		$value = ( empty( $value ) &amp;&amp; isset( $args['default_value'] ) ) ? $args['default_value'] : $value;
		$attrs = '';
		$class = '';

		switch ( $type ) {
			case 'text':
			case 'password':
				$attrs = ' value="' . esc_attr( $value ) . '"';
				$class = 'regular-text';
				break;
			case 'number':
				$attrs = ' value="' . esc_attr( $value ) . '"';

				if ( isset( $args['max'] ) &amp;&amp; is_numeric( $args['max'] ) ) {
					$attrs .= ' max="' . esc_attr( (float) $args['max'] ) . '"';
				}

				if ( isset( $args['min'] ) &amp;&amp; is_numeric( $args['min'] ) ) {
					$attrs .= ' min="' . esc_attr( (float) $args['min'] ) . '"';
				}

				if ( isset( $args['step'] ) &amp;&amp; is_numeric( $args['step'] ) ) {
					$attrs .= ' step="' . esc_attr( (float) $args['step'] ) . '"';
				}

				$class = 'small-text';
				break;
			case 'checkbox':
				$attrs = ' value="1"' . checked( '1', $value, false );
				?>
				&lt;input
					type="hidden"
					name="&lt;?php echo esc_attr( $this->get_option_name() ); ?>&lt;?php echo $option_index ? '[' . esc_attr( $option_index ) . ']' : ''; ?>[&lt;?php echo esc_attr( $args['label_for'] ); ?>]"
					value="0"
				/>
				&lt;?php
				break;
		}
		?>

		&lt;input
			type="&lt;?php echo esc_attr( $type ); ?>"
			id="&lt;?php echo esc_attr( $args['label_for'] ); ?>"
			class="&lt;?php echo esc_attr( $class ); ?>"
			name="&lt;?php echo esc_attr( $this->get_option_name() ); ?>&lt;?php echo $option_index ? '[' . esc_attr( $option_index ) . ']' : ''; ?>[&lt;?php echo esc_attr( $args['label_for'] ); ?>]"
			&lt;?php echo $this->get_data_attribute( $args ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped ?>
			&lt;?php echo $attrs; // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped ?> />

		&lt;?php
		if ( ! empty( $args['description'] ) ) {
			echo '&lt;span class="description classifai-input-description">' . wp_kses_post( $args['description'] ) . '&lt;/span>';
		}
	}

	/**
	 * Generic prompt repeater field callback
	 *
	 * @since 2.4.0
	 *
	 * @param array $args The args passed to add_settings_field.
	 */
	public function render_prompt_repeater_field( array $args ) {
		$option_index      = $args['option_index'] ?? false;
		$setting_index     = $this->get_settings( $option_index );
		$prompts           = $setting_index[ $args['label_for'] ] ?? [];
		$class             = $args['class'] ?? 'large-text';
		$placeholder       = $args['placeholder'] ?? '';
		$field_name_prefix = sprintf(
			'%1$s%2$s[%3$s]',
			$this->get_option_name(),
			$option_index ? "[$option_index]" : '',
			$args['label_for']
		);

		$prompts = empty( $prompts ) &amp;&amp; isset( $args['default_value'] ) ? $args['default_value'] : $prompts;

		$prompt_count = count( $prompts );
		$field_index  = 0;
		?>

		&lt;?php foreach ( $prompts as $prompt ) : ?>
			&lt;?php
			$is_default_prompt  = ( isset( $prompt['default'] ) &amp;&amp; 1 === (int) $prompt['default'] ) || 1 === $prompt_count;
			$is_original_prompt = isset( $prompt['original'] ) &amp;&amp; 1 === (int) $prompt['original'];
			?>

			&lt;fieldset class="classifai-field-type-prompt-setting">
				&lt;?php if ( $is_original_prompt ) : ?>
					&lt;p class="classifai-original-prompt">
						&lt;?php
						printf(
							/* translators: %1$s is replaced with &lt;strong>; %2$s with &lt;/strong>; %3$s with prompt. */
							esc_html__( '%1$sClassifAI default prompt%2$s: %3$s', 'classifai' ),
							'&lt;strong>',
							'&lt;/strong>',
							esc_html( $placeholder )
						);
						?>
					&lt;/p>
				&lt;?php endif; ?>

				&lt;input type="hidden"
					name="&lt;?php echo esc_attr( $field_name_prefix . "[$field_index][default]" ); ?>"
					value="&lt;?php echo esc_attr( $prompt['default'] ?? '' ); ?>"
					class="js-setting-field__default">
				&lt;input type="hidden"
					name="&lt;?php echo esc_attr( $field_name_prefix . "[$field_index][original]" ); ?>"
					value="&lt;?php echo esc_attr( $prompt['original'] ?? '' ); ?>">
				&lt;label>
					&lt;?php esc_html_e( 'Title', 'classifai' ); ?>&amp;nbsp;*
					&lt;span class="dashicons dashicons-editor-help"
						title="&lt;?php esc_attr_e( 'Short description of prompt to use for identification', 'classifai' ); ?>">&lt;/span>
					&lt;input type="text"
						name="&lt;?php echo esc_attr( $field_name_prefix . "[$field_index][title]" ); ?>"
						placeholder="&lt;?php esc_attr_e( 'Prompt title', 'classifai' ); ?>"
						value="&lt;?php echo esc_attr( $prompt['title'] ?? '' ); ?>"
						&lt;?php echo $is_original_prompt ? 'readonly' : ''; ?>
						required>
				&lt;/label>

				&lt;label>
					&lt;?php esc_html_e( 'Prompt', 'classifai' ); ?>
					&lt;textarea
						class="&lt;?php echo esc_attr( $class ); ?>"
						rows="4"
						name="&lt;?php echo esc_attr( $field_name_prefix . "[$field_index][prompt]" ); ?>"
						placeholder="&lt;?php echo esc_attr( $placeholder ); ?>"
						&lt;?php echo $is_original_prompt ? 'readonly' : ''; ?>
					>&lt;?php echo esc_textarea( $prompt['prompt'] ?? '' ); ?>&lt;/textarea>
				&lt;/label>

				&lt;div class="actions-rows">
					&lt;a href="#" class="action__set_default &lt;?php echo $is_default_prompt ? 'selected' : ''; ?>">
						&lt;?php if ( $is_default_prompt ) : ?>
							&lt;?php esc_html_e( 'Default prompt', 'classifai' ); ?>
						&lt;?php else : ?>
							&lt;?php esc_html_e( 'Set as default prompt', 'classifai' ); ?>
						&lt;?php endif; ?>
					&lt;/a>
					&lt;a href="#" class="action__remove_prompt" style="&lt;?php echo 1 === $prompt_count || $is_original_prompt ? 'display:none;' : ''; ?>">
						&lt;?php esc_html_e( 'Trash', 'classifai' ); ?>
					&lt;/a>
				&lt;/div>
			&lt;/fieldset>
			&lt;?php ++$field_index; ?>
		&lt;?php endforeach; ?>

		&lt;button
			class="button-secondary js-classifai-add-prompt-fieldset">
			&lt;?php esc_html_e( 'Add new prompt', 'classifai' ); ?>
		&lt;/button>

		&lt;?php
		if ( ! empty( $args['description'] ) ) {
			echo '&lt;br />&lt;span class="description classifai-input-description">' . wp_kses_post( $args['description'] ) . '&lt;/span>';
		}
	}

	/**
	 * Renders a select menu
	 *
	 * @param array $args The args passed to add_settings_field.
	 */
	public function render_select( array $args ) {
		$option_index  = isset( $args['option_index'] ) ? $args['option_index'] : false;
		$setting_index = $this->get_settings( $option_index );
		$saved         = ( isset( $setting_index[ $args['label_for'] ] ) ) ? $setting_index[ $args['label_for'] ] : '';

		// Check for a default value
		$saved   = ( empty( $saved ) &amp;&amp; isset( $args['default_value'] ) ) ? $args['default_value'] : $saved;
		$options = isset( $args['options'] ) ? $args['options'] : [];
		?>

		&lt;select
			id="&lt;?php echo esc_attr( $args['label_for'] ); ?>"
			name="&lt;?php echo esc_attr( $this->get_option_name() ); ?>&lt;?php echo $option_index ? '[' . esc_attr( $option_index ) . ']' : ''; ?>[&lt;?php echo esc_attr( $args['label_for'] ); ?>]"
			&lt;?php echo $this->get_data_attribute( $args ); // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped ?>
			>
			&lt;?php foreach ( $options as $value => $name ) : ?>
				&lt;option value="&lt;?php echo esc_attr( $value ); ?>" &lt;?php selected( $saved, $value ); ?>>
					&lt;?php echo esc_attr( $name ); ?>
				&lt;/option>
			&lt;?php endforeach; ?>
		&lt;/select>

		&lt;?php
		if ( ! empty( $args['description'] ) ) {
			echo '&lt;br />&lt;span class="description">' . wp_kses_post( $args['description'] ) . '&lt;/span>';
		}
	}

	/**
	 * Render a group of checkboxes.
	 *
	 * @param array $args The args passed to add_settings_field
	 */
	public function render_checkbox_group( array $args = array() ) {
		$option_index  = isset( $args['option_index'] ) ? $args['option_index'] : false;
		$setting_index = $this->get_settings();

		// Iterate through all of our options.
		foreach ( $args['options'] as $option_value => $option_label ) {
			$value       = '';
			$default_key = array_search( $option_value, $args['default_values'], true );

			// Get saved value, if any.
			if ( isset( $setting_index[ $args['label_for'] ] ) ) {
				$value = $setting_index[ $args['label_for'] ][ $option_value ] ?? '';
			}

			// If no saved value, check if we have a default value.
			if ( empty( $value ) &amp;&amp; '0' !== $value &amp;&amp; isset( $args['default_values'][ $default_key ] ) ) {
				$value = $args['default_values'][ $default_key ];
			}

			// Render checkbox.
			printf(
				'&lt;p>
					&lt;label for="%1$s_%3$s_%4$s">
						&lt;input type="hidden" name="%1$s%2$s[%3$s][%4$s]" value="0" />
						&lt;input type="checkbox" id="%1$s_%3$s_%4$s" name="%1$s%2$s[%3$s][%4$s]" value="%4$s" %5$s />
						%6$s
					&lt;/label>
				&lt;/p>',
				esc_attr( $this->get_option_name() ),
				$option_index ? '[' . esc_attr( $option_index ) . ']' : '',
				esc_attr( $args['label_for'] ),
				esc_attr( $option_value ),
				checked( $value, $option_value, false ),
				esc_html( $option_label )
			);
		}

		// Render description, if any.
		if ( ! empty( $args['description'] ) ) {
			printf(
				'&lt;span class="description classifai-input-description">%s&lt;/span>',
				esc_html( $args['description'] )
			);
		}
	}

	/**
	 * Renders the checkbox group for 'Generate descriptive text' setting.
	 *
	 * @param array $args The args passed to add_settings_field.
	 */
	public function render_auto_caption_fields( array $args ) {
		$setting_index = $this->get_settings();
		$default_value = '';

		if ( isset( $setting_index['enable_image_captions'] ) ) {
			if ( ! is_array( $setting_index['enable_image_captions'] ) ) {
				if ( '1' === $setting_index['enable_image_captions'] ) {
					$default_value = 'alt';
				} elseif ( 'no' === $setting_index['enable_image_captions'] ) {
					$default_value = '';
				}
			}
		}

		$checkbox_options = array(
			'alt'         => esc_html__( 'Alt text', 'classifai' ),
			'caption'     => esc_html__( 'Image caption', 'classifai' ),
			'description' => esc_html__( 'Image description', 'classifai' ),
		);

		foreach ( $checkbox_options as $option_value => $option_label ) {
			if ( isset( $setting_index['enable_image_captions'] ) ) {
				if ( ! is_array( $setting_index['enable_image_captions'] ) ) {
					$default_value = '1' === $setting_index['enable_image_captions'] ? 'alt' : '';
				} else {
					$default_value = $setting_index['enable_image_captions'][ $option_value ];
				}
			}

			printf(
				'&lt;p>
					&lt;label for="%1$s_%2$s_%3$s">
						&lt;input type="hidden" name="%1$s[%2$s][%3$s]" value="0" />
						&lt;input type="checkbox" id="%1$s_%2$s_%3$s" name="%1$s[%2$s][%3$s]" value="%3$s" %4$s />
						%5$s
					&lt;/label>
				&lt;/p>',
				esc_attr( $this->get_option_name() ),
				esc_attr( $args['label_for'] ),
				esc_attr( $option_value ),
				checked( $default_value, $option_value, false ),
				esc_html( $option_label )
			);
		}

		// Render description, if any.
		if ( ! empty( $args['description'] ) ) {
			printf(
				'&lt;span class="description classifai-input-description">%s&lt;/span>',
				esc_html( $args['description'] )
			);
		}
	}

	/**
	 * Render a group of radio.
	 *
	 * @param array $args The args passed to add_settings_field
	 */
	public function render_radio_group( array $args = array() ) {
		$option_index  = isset( $args['option_index'] ) ? $args['option_index'] : false;
		$setting_index = $this->get_settings( $option_index );
		$value         = $setting_index[ $args['label_for'] ] ?? '';
		$options       = $args['options'] ?? [];

		if ( ! is_array( $options ) ) {
			return;
		}

		// Iterate through all of our options.
		foreach ( $options as $option_value => $option_label ) {
			// Render radio button.
			printf(
				'&lt;p>
					&lt;label for="%1$s_%3$s_%4$s">
						&lt;input type="radio" id="%1$s_%3$s_%4$s" name="%1$s%2$s[%3$s]" value="%4$s" %5$s />
						%6$s
					&lt;/label>
				&lt;/p>',
				esc_attr( $this->get_option_name() ),
				$option_index ? '[' . esc_attr( $option_index ) . ']' : '',
				esc_attr( $args['label_for'] ),
				esc_attr( $option_value ),
				checked( $value, $option_value, false ),
				esc_html( $option_label )
			);
		}

		// Render description, if any.
		if ( ! empty( $args['description'] ) ) {
			printf(
				'&lt;span class="description">%s&lt;/span>',
				esc_html( $args['description'] )
			);
		}
	}

	/**
	 * Render allowed users input field.
	 *
	 * @param array $args The args passed to add_settings_field
	 */
	public function render_allowed_users( array $args = array() ) {
		$setting_index = $this->get_settings();
		$value         = $setting_index[ $args['label_for'] ] ?? array();
		?>
		&lt;div class="classifai-search-users-container">
			&lt;div class="classifai-user-selector" data-id="&lt;?php echo esc_attr( $args['label_for'] ); ?>" id="&lt;?php echo esc_attr( $args['label_for'] ); ?>-container">&lt;/div>
			&lt;input
				id="&lt;?php echo esc_attr( $args['label_for'] ); ?>"
				class="classifai-search-users"
				type="hidden"
				name="&lt;?php echo esc_attr( $this->get_option_name() ); ?>[&lt;?php echo esc_attr( $args['label_for'] ); ?>]"
				value="&lt;?php echo esc_attr( implode( ',', $value ) ); ?>"
			/>
		&lt;/div>
		&lt;?php
		if ( ! empty( $args['description'] ) ) {
			echo '&lt;span class="description">' . wp_kses_post( $args['description'] ) . '&lt;/span>';
		}
	}

	/**
	 * Determine if the current user has access to the feature
	 *
	 * @return bool
	 */
	public function has_access(): bool {
		$access        = false;
		$user_id       = get_current_user_id();
		$user          = get_user_by( 'id', $user_id );
		$user_roles    = $user->roles ?? [];
		$settings      = $this->get_settings();
		$feature_roles = $settings['roles'] ?? [];
		$feature_users = array_map( 'absint', $settings['users'] ?? [] );

		$user_based_opt_out_enabled = isset( $settings['user_based_opt_out'] ) &amp;&amp; 1 === (int) $settings['user_based_opt_out'];

		/*
		 * Checks if the user role has access to the feature.
		 */
		// For super admins that don't have a specific role on a site, treat them as admins.
		if ( is_multisite() &amp;&amp; is_super_admin( $user_id ) &amp;&amp; empty( $user_roles ) ) {
			$user_roles = [ 'administrator' ];
		}

		$access = ( ! empty( $feature_roles ) &amp;&amp; ! empty( array_intersect( $user_roles, $feature_roles ) ) );

		/*
		 * Checks if has access to the feature.
		 */
		if ( ! $access ) {
			$access = ( ! empty( $feature_users ) &amp;&amp; ! empty( in_array( $user_id, $feature_users, true ) ) );
		}

		/*
		 * Checks if User-based opt-out is enabled and user has opted out from the feature.
		 */
		if ( $access &amp;&amp; $user_based_opt_out_enabled ) {
			$opted_out_features = (array) get_user_meta( $user_id, 'classifai_opted_out_features', true );
			$access             = ( ! in_array( static::ID, $opted_out_features, true ) );
		}

		if ( defined( 'WP_CLI' ) &amp;&amp; WP_CLI ) {
			$access = true;
		}

		/**
		 * Filter to override user access to a ClassifAI feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{$feature}_has_access
		 *
		 * @param {bool}  $access   Current access value.
		 * @param {array} $settings Feature settings.
		 *
		 * @return {bool} Should the user have access?
		 */
		return apply_filters( 'classifai_' . static::ID . '_has_access', $access, $settings );
	}

	/**
	 * Determine if a feature is enabled.
	 *
	 * Returns true if the feature meets all the criteria to
	 * be enabled. False otherwise.
	 *
	 * Criteria:
	 *  - Provider is configured.
	 *  - User has access to the feature.
	 *  - Feature is turned on.
	 *
	 * @return bool
	 */
	public function is_feature_enabled(): bool {
		$is_feature_enabled = false;
		$settings           = $this->get_settings();

		// Check if provider is configured, user has access to the feature and the feature is turned on.
		if (
			$this->is_configured() &amp;&amp;
			$this->has_access() &amp;&amp;
			$this->is_enabled()
		) {
			$is_feature_enabled = true;
		}

		/**
		 * Filter to override permission to a specific classifai feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{$feature}_is_feature_enabled
		 *
		 * @param {bool}  $is_feature_enabled Is the feature enabled?
		 * @param {array} $settings           Current feature settings.
		 *
		 * @return {bool} Returns true if the user has access and the feature is enabled, false otherwise.
		 */
		return apply_filters( 'classifai_' . static::ID . '_is_feature_enabled', $is_feature_enabled, $settings );
	}

	/**
	 * Determine if the feature is turned on.
	 *
	 * Note: This function does not check if the user has access to the feature.
	 *
	 * - Use `is_feature_enabled()` to check if the user has access to the feature and feature is turned on.
	 * - Use `has_access()` to check if the user has access to the feature.
	 *
	 * @return bool
	 */
	public function is_enabled(): bool {
		$settings = $this->get_settings();

		// Check if feature is turned on.
		$feature_status = ( isset( $settings['status'] ) &amp;&amp; 1 === (int) $settings['status'] );
		$is_configured  = $this->is_configured();
		$is_enabled     = $feature_status &amp;&amp; $is_configured;

		/**
		 * Filter to override a specific classifai feature enabled.
		 *
		 * @since 3.0.0
		 * @hook classifai_{$feature}_is_enabled
		 *
		 * @param {bool}  $is_enabled Is the feature enabled?
		 * @param {array} $settings   Current feature settings.
		 *
		 * @return {bool} Returns true if the feature is enabled, false otherwise.
		 */
		return apply_filters( 'classifai_' . static::ID . '_is_enabled', $is_enabled, $settings );
	}

	/**
	 * The list of post types that are supported.
	 *
	 * @return array
	 */
	public function get_supported_post_types(): array {
		$settings   = $this->get_settings();
		$post_types = [];

		if ( isset( $settings['post_types'] ) &amp;&amp; is_array( $settings['post_types'] ) ) {
			foreach ( $settings['post_types'] as $post_type => $enabled ) {
				if ( ! empty( $enabled ) ) {
					$post_types[] = $post_type;
				}
			}
		}

		/**
		 * Filter post types supported for a feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_post_types
		 *
		 * @param {array} $post_types Array of post types to be classified.
		 *
		 * @return {array} Array of post types.
		 */
		$post_types = apply_filters( 'classifai_' . static::ID . '_post_types', $post_types );

		return $post_types;
	}

	/**
	 * The list of post statuses that are supported.
	 *
	 * @return array
	 */
	public function get_supported_post_statuses(): array {
		$settings      = $this->get_settings();
		$post_statuses = [];

		if ( ! empty( $settings ) &amp;&amp; isset( $settings['post_statuses'] ) ) {
			foreach ( $settings['post_statuses'] as $post_status => $enabled ) {
				if ( ! empty( $enabled ) ) {
					$post_statuses[] = $post_status;
				}
			}
		}

		/**
		 * Filter post statuses supported for a feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_post_statuses
		 *
		 * @param {array} $post_types Array of post statuses to be classified.
		 *
		 * @return {array} Array of post statuses.
		 */
		$post_statuses = apply_filters( 'classifai_' . static::ID . '_post_statuses', $post_statuses );

		return $post_statuses;
	}

	/**
	 * Returns array of instances of provider classes registered for the service.
	 *
	 * @internal
	 *
	 * @param array $services Array of provider classes.
	 * @return array
	 */
	protected function get_provider_instances( array $services ): array {
		$provider_instances = [];

		foreach ( $services as $provider_class ) {
			$provider_instances[] = new $provider_class();
		}

		return $provider_instances;
	}

	/**
	 * Returns the instance of the provider set for the feature.
	 *
	 * @param string $provider_id The ID of the provider.
	 * @return \Classifai\Providers
	 */
	public function get_feature_provider_instance( string $provider_id = '' ) {
		$provider_id       = $provider_id ? $provider_id : $this->get_settings( 'provider' );
		$provider_instance = find_provider_class( $this->provider_instances ?? [], $provider_id );

		if ( is_wp_error( $provider_instance ) ) {
			return null;
		}

		$provider_class    = get_class( $provider_instance );
		$provider_instance = new $provider_class( $this );

		return $provider_instance;
	}

	/**
	 * Returns whether the provider is configured or not.
	 *
	 * @return bool
	 */
	public function is_configured(): bool {
		$settings      = $this->get_settings();
		$provider_id   = $settings['provider'];
		$is_configured = false;

		if ( ! empty( $settings ) &amp;&amp; ! empty( $settings[ $provider_id ]['authenticated'] ) ) {
			$is_configured = true;
		}

		return $is_configured;
	}

	/**
	 * Can the feature be initialized?
	 *
	 * @return bool
	 */
	public function can_register(): bool {
		return $this->is_configured();
	}

	/**
	 * Get the debug value text.
	 *
	 * @param mixed   $setting_value The value of the setting.
	 * @param integer $type The type of debug value to return.
	 * @return string
	 */
	public static function get_debug_value_text( $setting_value, $type = 0 ): string {
		$debug_value = '';

		if ( empty( $setting_value ) ) {
			$boolean = false;
		} elseif ( 'no' === $setting_value ) {
			$boolean = false;
		} else {
			$boolean = true;
		}

		switch ( $type ) {
			case 0:
				$debug_value = $boolean ? __( 'Yes', 'classifai' ) : __( 'No', 'classifai' );
				break;
			case 1:
				$debug_value = $boolean ? __( 'Enabled', 'classifai' ) : __( 'Disabled', 'classifai' );
				break;
		}

		return $debug_value;
	}

	/**
	 * Returns an array of feature-level debug info.
	 *
	 * @return array
	 */
	public function get_debug_information(): array {
		$feature_settings = $this->get_settings();
		$provider         = $this->get_feature_provider_instance();

		$roles = array_filter(
			$feature_settings['roles'],
			function ( $role ) {
				return '0' !== $role;
			}
		);

		$common_debug_info = [
			__( 'Authenticated', 'classifai' )          => self::get_debug_value_text( $this->is_configured() ),
			__( 'Status', 'classifai' )                 => self::get_debug_value_text( $feature_settings['status'], 1 ),
			__( 'Allowed roles (titles)', 'classifai' ) => implode( ', ', $roles ?? [] ),
			__( 'Allowed users (titles)', 'classifai' ) => implode( ', ', $feature_settings['users'] ?? [] ),
			__( 'User based opt-out', 'classifai' )     => self::get_debug_value_text( $feature_settings['user_based_opt_out'], 1 ),
			__( 'Provider', 'classifai' )               => $feature_settings['provider'],
		];

		if ( $provider &amp;&amp; method_exists( $provider, 'get_debug_information' ) ) {
			$all_debug_info = array_merge(
				$common_debug_info,
				$provider->get_debug_information()
			);
		} else {
			$all_debug_info = $common_debug_info;
		}

		/**
		 * Filter to add feature-level debug information.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_debug_information
		 *
		 * @param {array} $all_debug_info Debug information
		 * @param {object} $this Current feature class.
		 *
		 * @return {array} Returns debug information.
		 */
		return apply_filters(
			'classifai_' . self::ID . '_debug_information',
			$all_debug_info,
			$this,
		);
	}

	/**
	 * Returns the data attribute string for an input.
	 *
	 * @param array $args The args passed to add_settings_field.
	 * @return string
	 */
	protected function get_data_attribute( array $args ): string {
		$data_attr     = $args['data_attr'] ?? [];
		$data_attr_str = '';

		foreach ( $data_attr as $attr_key => $attr_value ) {
			if ( is_scalar( $attr_value ) ) {
				$data_attr_str .= 'data-' . $attr_key . '="' . esc_attr( $attr_value ) . '"';
			} else {
				$data_attr_str .= 'data-' . $attr_key . '="' . esc_attr( wp_json_encode( $attr_value ) ) . '"';
			}
		}

		return $data_attr_str;
	}

	/**
	 * Register any needed endpoints.
	 */
	public function register_endpoints() {}

	/**
	 * Generic callback that can be used for all custom endpoints.
	 *
	 * @param WP_REST_Request $request The full request object.
	 * @return \WP_REST_Response|WP_Error
	 */
	public function rest_endpoint_callback( WP_REST_Request $request ) { // phpcs:ignore Generic.CodeAnalysis.UnusedFunctionParameter.Found
		return rest_ensure_response( new WP_Error( 'invalid_route', esc_html__( 'Invalid route.', 'classifai' ) ) );
	}

	/**
	 * Runs the feature.
	 *
	 * @param mixed ...$args Arguments required by the feature depending on the provider selected.
	 * @return mixed
	 */
	public function run( ...$args ) {
		$settings          = $this->get_settings();
		$provider_id       = $settings['provider'];
		$provider_instance = $this->get_feature_provider_instance( $provider_id );

		if ( ! is_callable( [ $provider_instance, 'rest_endpoint_callback' ] ) ) {
			return new WP_Error( 'invalid_route', esc_html__( 'The selected provider does not have a valid callback in place.', 'classifai' ) );
		}

		/**
		 * Filter the results of running the feature.
		 *
		 * @since 3.0.0
		 * @hook classifai_{feature}_run
		 *
		 * @param {mixed} $result Result of running the feature.
		 * @param {Providers} $provider_instance Provider used.
		 * @param {mixed} $args Arguments used by the feature.
		 * @param {Feature} $this Current feature class.
		 *
		 * @return {mixed} Results.
		 */
		return apply_filters(
			'classifai_' . static::ID . '_run',
			$provider_instance->rest_endpoint_callback( ...$args ),
			$provider_instance,
			$args,
			$this
		);
	}
}
</code></pre>
        </article>
    </section>





    <footer>
		<a href="https://classifaiplugin.com/">ClassifAI Plugin</a> &bull;
		<a href="https://github.com/10up/classifai/">ClassifAI on GitHub</a> &bull;
		<a href="https://10up.com/careers">Careers at 10up</a>
	</footer>


</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Actions</h3><ul><li><a href="after_classifai_init.html">after_classifai_init</a></li><li><a href="before_classifai_init.html">before_classifai_init</a></li><li><a href="classifai_after_feature_settings_form.html">classifai_after_feature_settings_form</a></li><li><a href="classifai_azure_read_after_request.html">classifai_azure_read_after_request</a></li><li><a href="classifai_before_feature_nav.html">classifai_before_feature_nav</a></li><li><a href="classifai_before_feature_settings_form.html">classifai_before_feature_settings_form</a></li><li><a href="classifai_computer_vision_caption_failed.html">classifai_computer_vision_caption_failed</a></li><li><a href="classifai_computer_vision_image_tag_failed.html">classifai_computer_vision_image_tag_failed</a></li><li><a href="classifai_ms_computer_vision_render_provider_fields.html">classifai_ms_computer_vision_render_provider_fields</a></li><li><a href="classifai_ocr_after_request.html">classifai_ocr_after_request</a></li><li><a href="classifai_ocr_unsuccessful_response.html">classifai_ocr_unsuccessful_response</a></li><li><a href="classifai_render_attachment_metabox.html">classifai_render_attachment_metabox</a></li><li><a href="classifai_smart_cropping_after_request.html">classifai_smart_cropping_after_request</a></li><li><a href="classifai_smart_cropping_unsuccessful_response.html">classifai_smart_cropping_unsuccessful_response</a></li></ul><h3>Filters</h3><ul><li><a href="classifai_all_post_statuses.html">classifai_all_post_statuses</a></li><li><a href="classifai_audio_generation_initial_state.html">classifai_audio_generation_initial_state</a></li><li><a href="classifai_audio_generation_subsequent_state.html">classifai_audio_generation_subsequent_state</a></li><li><a href="classifai_azure_openai_content.html">classifai_azure_openai_content</a></li><li><a href="classifai_azure_openai_excerpt_prompt.html">classifai_azure_openai_excerpt_prompt</a></li><li><a href="classifai_azure_openai_excerpt_request_body.html">classifai_azure_openai_excerpt_request_body</a></li><li><a href="classifai_azure_openai_resize_content_request_body.html">classifai_azure_openai_resize_content_request_body</a></li><li><a href="classifai_azure_openai_title_prompt.html">classifai_azure_openai_title_prompt</a></li><li><a href="classifai_azure_openai_title_request_body.html">classifai_azure_openai_title_request_body</a></li><li><a href="classifai_azure_read_request_args.html">classifai_azure_read_request_args</a></li><li><a href="classifai_azure_read_result_max_page.html">classifai_azure_read_result_max_page</a></li><li><a href="classifai_azure_read_retry_interval.html">classifai_azure_read_retry_interval</a></li><li><a href="classifai_azure_read_should_process.html">classifai_azure_read_should_process</a></li><li><a href="classifai_azure_read_text_result.html">classifai_azure_read_text_result</a></li><li><a href="classifai_chatgpt_content.html">classifai_chatgpt_content</a></li><li><a href="classifai_chatgpt_excerpt_prompt.html">classifai_chatgpt_excerpt_prompt</a></li><li><a href="classifai_chatgpt_excerpt_request_body.html">classifai_chatgpt_excerpt_request_body</a></li><li><a href="classifai_chatgpt_resize_content_request_body.html">classifai_chatgpt_resize_content_request_body</a></li><li><a href="classifai_chatgpt_title_prompt.html">classifai_chatgpt_title_prompt</a></li><li><a href="classifai_chatgpt_title_request_body.html">classifai_chatgpt_title_request_body</a></li><li><a href="classifai_classified_data.html">classifai_classified_data</a></li><li><a href="classifai_computer_vision_captions.html">classifai_computer_vision_captions</a></li><li><a href="classifai_computer_vision_image_tags.html">classifai_computer_vision_image_tags</a></li><li><a href="classifai_computer_vision_max_filesize.html">classifai_computer_vision_max_filesize</a></li><li><a href="classifai_dalle_caption.html">classifai_dalle_caption</a></li><li><a href="classifai_dalle_prompt.html">classifai_dalle_prompt</a></li><li><a href="classifai_dalle_request_body.html">classifai_dalle_request_body</a></li><li><a href="classifai_debug_information.html">classifai_debug_information</a></li><li><a href="classifai_disable_post_to_audio_block.html">classifai_disable_post_to_audio_block</a></li><li><a href="classifai_feature_classification_setting_taxonomies.html">classifai_feature_classification_setting_taxonomies</a></li><li><a href="classifai_feature_classification_taxonomy_for_feature.html">classifai_feature_classification_taxonomy_for_feature</a></li><li><a href="classifai_feature_image_generation_roles.html">classifai_feature_image_generation_roles</a></li><li><a href="classifai_feature_pdf_to_text_generation_read_status.html">classifai_feature_pdf_to_text_generation_read_status</a></li><li><a href="classifai_feature_threshold.html">classifai_feature_threshold</a></li><li><a href="classifai_generate_image_alt_tags_source_url.html">classifai_generate_image_alt_tags_source_url</a></li><li><a href="classifai_googleai_api_request_get_options.html">classifai_googleai_api_request_get_options</a></li><li><a href="classifai_googleai_api_request_get_url.html">classifai_googleai_api_request_get_url</a></li><li><a href="classifai_googleai_api_request_post_options.html">classifai_googleai_api_request_post_options</a></li><li><a href="classifai_googleai_api_request_post_url.html">classifai_googleai_api_request_post_url</a></li><li><a href="classifai_googleai_api_response_get.html">classifai_googleai_api_response_get</a></li><li><a href="classifai_googleai_api_response_post.html">classifai_googleai_api_response_post</a></li><li><a href="classifai_googleai_content.html">classifai_googleai_content</a></li><li><a href="classifai_googleai_gemini_api_excerpt_prompt.html">classifai_googleai_gemini_api_excerpt_prompt</a></li><li><a href="classifai_googleai_gemini_api_excerpt_request_body.html">classifai_googleai_gemini_api_excerpt_request_body</a></li><li><a href="classifai_googleai_gemini_api_resize_content_request_body.html">classifai_googleai_gemini_api_resize_content_request_body</a></li><li><a href="classifai_googleai_gemini_api_title_prompt.html">classifai_googleai_gemini_api_title_prompt</a></li><li><a href="classifai_googleai_gemini_api_title_request_body.html">classifai_googleai_gemini_api_title_request_body</a></li><li><a href="classifai_image_processing_service_providers.html">classifai_image_processing_service_providers</a></li><li><a href="classifai_language_processing_service_providers.html">classifai_language_processing_service_providers</a></li><li><a href="classifai_language_settings_post_statuses.html">classifai_language_settings_post_statuses</a></li><li><a href="classifai_language_settings_post_types.html">classifai_language_settings_post_types</a></li><li><a href="classifai_listen_to_this_post_text.html">classifai_listen_to_this_post_text</a></li><li><a href="classifai_normalize.html">classifai_normalize</a></li><li><a href="classifai_ocr_approved_media_types.html">classifai_ocr_approved_media_types</a></li><li><a href="classifai_ocr_should_process.html">classifai_ocr_should_process</a></li><li><a href="classifai_ocr_tag_confidence.html">classifai_ocr_tag_confidence</a></li><li><a href="classifai_ocr_tags.html">classifai_ocr_tags</a></li><li><a href="classifai_ocr_text.html">classifai_ocr_text</a></li><li><a href="classifai_ocr_text_post_args.html">classifai_ocr_text_post_args</a></li><li><a href="classifai_openai_api_request_get_options.html">classifai_openai_api_request_get_options</a></li><li><a href="classifai_openai_api_request_get_url.html">classifai_openai_api_request_get_url</a></li><li><a href="classifai_openai_api_request_post_form_options.html">classifai_openai_api_request_post_form_options</a></li><li><a href="classifai_openai_api_request_post_form_url.html">classifai_openai_api_request_post_form_url</a></li><li><a href="classifai_openai_api_request_post_options.html">classifai_openai_api_request_post_options</a></li><li><a href="classifai_openai_api_request_post_url.html">classifai_openai_api_request_post_url</a></li><li><a href="classifai_openai_api_response_get.html">classifai_openai_api_response_get</a></li><li><a href="classifai_openai_api_response_post.html">classifai_openai_api_response_post</a></li><li><a href="classifai_openai_api_response_post_form.html">classifai_openai_api_response_post_form</a></li><li><a href="classifai_openai_characters_in_token.html">classifai_openai_characters_in_token</a></li><li><a href="classifai_openai_embeddings_content.html">classifai_openai_embeddings_content</a></li><li><a href="classifai_openai_embeddings_request_body.html">classifai_openai_embeddings_request_body</a></li><li><a href="classifai_openai_embeddings_should_classify.html">classifai_openai_embeddings_should_classify</a></li><li><a href="classifai_openai_moderation_request_body.html">classifai_openai_moderation_request_body</a></li><li><a href="classifai_openai_settings_post_statuses.html">classifai_openai_settings_post_statuses</a></li><li><a href="classifai_openai_settings_post_types.html">classifai_openai_settings_post_types</a></li><li><a href="classifai_openai_settings_taxonomies.html">classifai_openai_settings_taxonomies</a></li><li><a href="classifai_openai_tokens_per_word.html">classifai_openai_tokens_per_word</a></li><li><a href="classifai_pre_render_post_audio_controls.html">classifai_pre_render_post_audio_controls</a></li><li><a href="classifai_recommendation_service_providers.html">classifai_recommendation_service_providers</a></li><li><a href="classifai_recommended_block_attributes.html">classifai_recommended_block_attributes</a></li><li><a href="classifai_recommended_block_markup.html">classifai_recommended_block_markup</a></li><li><a href="classifai_recommended_content_post_args.html">classifai_recommended_content_post_args</a></li><li><a href="classifai_services.html">classifai_services</a></li><li><a href="classifai_should_classify_post.html">classifai_should_classify_post</a></li><li><a href="classifai_should_crop_size.html">classifai_should_crop_size</a></li><li><a href="classifai_should_ocr_scan_image.html">classifai_should_ocr_scan_image</a></li><li><a href="classifai_should_smart_crop_image.html">classifai_should_smart_crop_image</a></li><li><a href="classifai_smart_crop_max_pixel_dimension.html">classifai_smart_crop_max_pixel_dimension</a></li><li><a href="classifai_smart_crop_wp_filesystem.html">classifai_smart_crop_wp_filesystem</a></li><li><a href="classifai_smart_cropping_source_url.html">classifai_smart_cropping_source_url</a></li><li><a href="classifai_smart_cropping_thumb_file_name.html">classifai_smart_cropping_thumb_file_name</a></li><li><a href="classifai_threshold.html">classifai_threshold</a></li><li><a href="classifai_whisper_transcribe_request_body.html">classifai_whisper_transcribe_request_body</a></li><li><a href="classifai_whisper_transcribe_result.html">classifai_whisper_transcribe_result</a></li><li><a href="classifai_%257B$feature%257D_has_access.html">classifai_{$feature}_has_access</a></li><li><a href="classifai_%257B$feature%257D_is_enabled.html">classifai_{$feature}_is_enabled</a></li><li><a href="classifai_%257B$feature%257D_is_feature_enabled.html">classifai_{$feature}_is_feature_enabled</a></li><li><a href="classifai_%257B$feature%257D_sanitize_settings.html">classifai_{$feature}_sanitize_settings</a></li><li><a href="classifai_%257Bfeature%257D_debug_information.html">classifai_{feature}_debug_information</a></li><li><a href="classifai_%257Bfeature%257D_get_default_settings.html">classifai_{feature}_get_default_settings</a></li><li><a href="classifai_%257Bfeature%257D_label.html">classifai_{feature}_label</a></li><li><a href="classifai_%257Bfeature%257D_post_statuses.html">classifai_{feature}_post_statuses</a></li><li><a href="classifai_%257Bfeature%257D_post_types.html">classifai_{feature}_post_types</a></li><li><a href="classifai_%257Bfeature%257D_providers.html">classifai_{feature}_providers</a></li><li><a href="classifai_%257Bfeature%257D_rest_route_%257Broute%257D_args.html">classifai_{feature}_rest_route_{route}_args</a></li><li><a href="classifai_%257Bfeature%257D_roles.html">classifai_{feature}_roles</a></li><li><a href="classifai_%257Bfeature%257D_run.html">classifai_{feature}_run</a></li><li><a href="%257B$this-_menu_slug%257D_features.html">{$this->menu_slug}_features</a></li><li><a href="%257B$this-_menu_slug%257D_providers.html">{$this->menu_slug}_providers</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-migration-guide-v2-to-v3.html">Migration guide (version 2 to version 3)</a></li><li><a href="tutorial-useful-snippets.html">Useful snippets</a></li><li><a href="tutorial-wp-cli.html">WP-CLI commands</a></li></ul>
</nav>

<br class="clear">

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
